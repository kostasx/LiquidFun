// Generated by CoffeeScript 1.10.0
var QueryCallback, ResetWorld, Step, TestOrientation, Testbed, camera, container, deviceOrientationListener, g_groundBody, getMouseCoords, initTestbed, objects, onWindowResize, particleColors, planeZ, positionIterations, projector, render, renderer, scene, test, threeRenderer, timeStep, velocityIterations, windowHeight, windowWidth, world;

particleColors = [new b2ParticleColor(0xff, 0x00, 0x00, 0xff), new b2ParticleColor(0x00, 0xff, 0x00, 0xff), new b2ParticleColor(0x00, 0x00, 0xff, 0xff), new b2ParticleColor(0xff, 0x8c, 0x00, 0xff), new b2ParticleColor(0x00, 0xce, 0xd1, 0xff), new b2ParticleColor(0xff, 0x00, 0xff, 0xff), new b2ParticleColor(0xff, 0xd7, 0x00, 0xff), new b2ParticleColor(0x00, 0xff, 0xff, 0xff)];

container = void 0;

world = null;

threeRenderer = void 0;

renderer = void 0;

camera = void 0;

scene = void 0;

objects = [];

timeStep = 1.0 / 60.0;

velocityIterations = 8;

positionIterations = 3;

test = {};

projector = new THREE.Projector;

planeZ = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);

g_groundBody = null;

windowWidth = window.innerWidth;

windowHeight = window.innerHeight;

render = function() {
  renderer.currentVertex = 0;
  if (test.Step !== void 0) {
    test.Step();
  } else {
    Step();
  }
  renderer.draw();
  threeRenderer.render(scene, camera);
  return requestAnimationFrame(render);
};

ResetWorld = function() {
  if (world !== null) {
    while (world.joints.length > 0) {
      world.DestroyJoint(world.joints[0]);
    }
    while (world.bodies.length > 0) {
      world.DestroyBody(world.bodies[0]);
    }
    while (world.particleSystems.length > 0) {
      world.DestroyParticleSystem(world.particleSystems[0]);
    }
  }
  camera.position.x = 0;
  camera.position.y = 0;
  return camera.position.z = 100;
};

Step = function() {
  return world.Step(timeStep, velocityIterations, positionIterations);
};

initTestbed = function() {
  var error, error1, gravity;
  camera = new THREE.PerspectiveCamera(70, windowWidth / windowHeight, 1, 1000);
  try {
    threeRenderer = new THREE.WebGLRenderer;
  } catch (error1) {
    error = error1;
    return console.log("Browser does not support WebGL");
  }
  threeRenderer.setClearColor(0xEEEEEE);
  threeRenderer.setSize(windowWidth, windowHeight);
  camera.position.x = 0;
  camera.position.y = 0;
  camera.position.z = 100;
  scene = new THREE.Scene;
  camera.lookAt(scene.position);
  document.body.appendChild(this.threeRenderer.domElement);
  this.mouseJoint = null;
  renderer = new Renderer;
  gravity = new b2Vec2(0, -10);
  world = new b2World(gravity);
  window.world = world;
  return Testbed();
};

Testbed = function(obj) {
  var bd, that;
  that = this;
  document.addEventListener('keypress', function(event) {
    if (test.Keyboard !== void 0) {
      test.Keyboard(String.fromCharCode(event.which));
    }
  });
  document.addEventListener('keyup', function(event) {
    if (test.KeyboardUp !== void 0) {
      test.KeyboardUp(String.fromCharCode(event.which));
    }
  });
  document.addEventListener('mousedown', function(event) {
    var aabb, body, d, md, p, queryCallback;
    p = getMouseCoords(event);
    aabb = new b2AABB;
    d = new b2Vec2;
    d.Set(0.01, 0.01);
    b2Vec2.Sub(aabb.lowerBound, p, d);
    b2Vec2.Add(aabb.upperBound, p, d);
    queryCallback = new QueryCallback(p);
    world.QueryAABB(queryCallback, aabb);
    if (queryCallback.fixture) {
      body = queryCallback.fixture.body;
      md = new b2MouseJointDef;
      md.bodyA = g_groundBody;
      md.bodyB = body;
      md.target = p;
      md.maxForce = 1000 * body.GetMass();
      that.mouseJoint = world.CreateJoint(md);
      body.SetAwake(true);
    }
    if (test.MouseDown !== void 0) {
      test.MouseDown(p);
    }
  });
  document.addEventListener('mousemove', function(event) {
    var p;
    p = getMouseCoords(event);
    if (that.mouseJoint) {
      that.mouseJoint.SetTarget(p);
    }
    if (test.MouseMove !== void 0) {
      test.MouseMove(p);
    }
  });
  document.addEventListener('mouseup', function(event) {
    if (that.mouseJoint) {
      world.DestroyJoint(that.mouseJoint);
      that.mouseJoint = null;
    }
    if (test.MouseUp !== void 0) {
      test.MouseUp(getMouseCoords(event));
    }
  });
  window.addEventListener('resize', onWindowResize, false);
  ResetWorld();
  world.SetGravity(new b2Vec2(0, -10));
  bd = new b2BodyDef;
  g_groundBody = world.CreateBody(bd);
  test = new window['TestOrientation'];
  return render();
};

QueryCallback = function(point) {
  this.point = point;
  return this.fixture = null;
};

onWindowResize = function() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  return threeRenderer.setSize(window.innerWidth, window.innerHeight);
};

getMouseCoords = function(event) {
  var dir, distance, mouse, p, pos;
  mouse = new THREE.Vector3;
  mouse.x = event.clientX / windowWidth * 2 - 1;
  mouse.y = -(event.clientY / windowHeight) * 2 + 1;
  mouse.z = 0.5;
  projector.unprojectVector(mouse, camera);
  dir = mouse.sub(camera.position).normalize();
  distance = -camera.position.z / dir.z;
  pos = camera.position.clone().add(dir.multiplyScalar(distance));
  p = new b2Vec2(pos.x, pos.y);
  return p;
};

QueryCallback.prototype.ReportFixture = function(fixture) {
  var body, inside;
  body = fixture.body;
  if (body.GetType() === b2_dynamicBody) {
    inside = fixture.TestPoint(this.point);
    if (inside) {
      this.fixture = fixture;
      return true;
    }
  }
  return false;
};

TestOrientation = function() {
  var base, bd, circle, ground, leftBlock, particleSystem, pgd, psd, rightBlock;
  camera.position.y = 4;
  camera.position.z = 8;
  bd = new b2BodyDef;
  ground = world.CreateBody(bd);
  base = new b2PolygonShape;
  base.vertices = [new b2Vec2(-10, -1), new b2Vec2(10, -1), new b2Vec2(10, -0.1), new b2Vec2(-10, -0.1)];
  leftBlock = new b2PolygonShape;
  leftBlock.vertices = [new b2Vec2(-8, -0.1), new b2Vec2(-6, -0.1), new b2Vec2(-6, 2), new b2Vec2(-8, 3)];
  rightBlock = new b2PolygonShape;
  rightBlock.vertices = [new b2Vec2(6, -0.1), new b2Vec2(8, -0.1), new b2Vec2(8, 3), new b2Vec2(6, 2)];
  ground.CreateFixtureFromShape(base, 0);
  ground.CreateFixtureFromShape(leftBlock, 0);
  ground.CreateFixtureFromShape(rightBlock, 0);
  psd = new b2ParticleSystemDef;
  psd.radius = 0.035;
  particleSystem = world.CreateParticleSystem(psd);
  circle = new b2CircleShape;
  circle.position.Set(0, 2);
  circle.radius = 2;
  pgd = new b2ParticleGroupDef;
  pgd.shape = circle;
  pgd.color.Set(55, 55, 255, 255);
  return particleSystem.CreateParticleGroup(pgd);
};

deviceOrientationListener = function(event) {
  var verticalSlide;
  verticalSlide = Math.round(event.gamma);
  return world.SetGravity(new b2Vec2(verticalSlide * 0.2, -10));
};

document.addEventListener("DOMContentLoaded", function() {
  if (window.DeviceOrientationEvent) {
    initTestbed();
    return window.addEventListener('deviceorientation', deviceOrientationListener);
  } else {
    return alert("Your browser does not support the DeviceOrientation API.");
  }
});
